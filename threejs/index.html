<!DOCTYPE html>
<html lang="ko">
<head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
     <script src="threejs/js/three.js"></script>
     <style>
          *{margin: 0;padding: 0;}
          #c{width: 100%;height: 100%;}
     </style>
</head>
<body>
     <canvas id="c"></canvas>
</body>
<script>
     main();
     function main(){
          const canvas = document.querySelector('#c');
          const renderer = new THREE.WebGLRenderer({canvas});

          const fov = 120;
          const aspect = 2;  // 캔버스 기본값
          const near = 0.1;
          const far = 5;
          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          camera.position.z = 3;
          camera.position.x = 1;
          camera.position.y = -0.5;

          const scene = new THREE.Scene();

          /*조명*/
               {
                    const color = 0xFFFFFF;
                    const intensity = 1;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(-1, 2, 4);
                    scene.add(light);
               }

          const boxWidth = 1;
          const boxHeight = 1;
          const boxDepth = 1;
          const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
          const radius = 2;  
          const height = 3.0;
         const segments = 26;  
         const radialSegments = 16; 
          const geometry_2 = new THREE.CircleGeometry(radius, segments);//원형
          const geometry_3 = new THREE.ConeGeometry(radius, height,radialSegments);//콘모양

               /*큐브 추가*/
          function makeInstance(geometry, color, x,y,z) {
                    const material = new THREE.MeshPhongMaterial({color});
                    
                    const cube = new THREE.Mesh(geometry, material);

                    scene.add(cube);
                    
                    cube.position.x = x;
                    cube.position.y = y;
                    cube.position.z = z;
                    
                    return cube;
               }
               
               //const material = new THREE.MeshPhongMaterial({color: 0x44aa88});//조명을 입히는 재질
        //  const material = new THREE.MeshBasicMaterial({color: 0x44aa88});///기본 재질

    /*큐브 추가*/
        const cubes = [
               makeInstance(geometry_3, 0x122882,  -1,2,1),
               makeInstance(geometry_2, 0x122882,  2,3,0),
               makeInstance(geometry, 0x44aa88,  0,1,1.5),
               makeInstance(geometry, 0x8844aa, -2,0,-2),
               makeInstance(geometry, 0xaa8844,  2,0,0),
               makeInstance(geometry, 0xaa8244,  4,0,0),
               makeInstance(geometry, 0xaa8004,  7,0,0),
          ];

          function resizeRendererToDisplaySize(renderer) {
                    const canvas = renderer.domElement;
                    const width = canvas.clientWidth;
                    const height = canvas.clientHeight;
                    const needResize = canvas.width !== width || canvas.height !== height;
                    if (needResize) {
                         renderer.setSize(width, height, false);
                    }
                    return needResize;
           }
           
           /*애니메이션*/
           function render(time) {
                time *= 0.001;  // 시간을 초로 변환
                
                if (resizeRendererToDisplaySize(renderer)) {
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
               }
                
                cubes.forEach((cube, ndx) => {
                     const speed = 1 + ndx * .1;
                     const rot = time * speed;
                     cube.rotation.x = rot;
                     cube.rotation.y = rot;
                    });
                    
               renderer.render(scene, camera);
               
               requestAnimationFrame(render);
               }

               requestAnimationFrame(render);
               
     }
</script>
</html>